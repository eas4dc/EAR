<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EAR: User guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">EAR<span id="projectnumber">&#160;4.3</span>
   </div>
   <div id="projectbrief">Reference Manual</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d6/d86/md_User_guide.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User guide </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#use-cases">Use cases</a><ul><li class="level2"><a href="#autotoc_md2">MPI applications</a><ul><li class="level3"><a href="#autotoc_md3">Hybrid MPI + (OpenMP, CUDA, MKL) applications</a></li>
<li class="level3"><a href="#autotoc_md4">Python MPI applications</a></li>
<li class="level3"><a href="#autotoc_md5">Running MPI applications on SLURM systems</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md6">Non-MPI applications</a><ul><li class="level3"><a href="#autotoc_md7">Python</a></li>
<li class="level3"><a href="#autotoc_md8">OpenMP, CUDA and Intel MKL</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md9">Other application types or frameworks</a></li>
<li class="level2"><a href="#autotoc_md10">Using EAR inside Singularity containers</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md11">Retrieving EAR data</a></li>
<li class="level1"><a href="#ear-job-submission-flags">EAR job submission flags</a><ul><li class="level2"><a href="#autotoc_md12">CPU frequency selection</a></li>
<li class="level2"><a href="#autotoc_md13">GPU frequency selection</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md14">Examples</a><ul><li class="level2"><a href="#autotoc_md15">srun examples</a></li>
<li class="level2"><a href="#autotoc_md16">sbatch + EARL + srun</a></li>
<li class="level2"><a href="#autotoc_md17">EARL + mpirun</a><ul><li class="level3"><a href="#autotoc_md18">Intel MPI</a></li>
<li class="level3"><a href="#openmpi-1">OpenMPI</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#eacct-1">EAR job Accounting (eacct)</a><ul><li class="level2"><a href="#autotoc_md19">Usage examples</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md20">Job energy optimization: EARL policies</a></li>
</ul>
</div>
<div class="textblock"><p>EAR was first designed to be usable 100% transparently by users, which means that you can run your applications enabling/disabling/tuning EAR with the less effort for changing your workflow, e.g., submission scripts. This is achieved by providing integrations (e.g., plug-ins, hooks) with system batch schedulers, which do all the effort to set-up EAR on job submission. By now, <b>SLURM is the batch scheduler full compatible with EAR</b> thanks to EAR's SLURM SPANK plug-in.</p>
<p>With EAR's SLURM plug-in, running an application with EAR is as easy as submitting a job with either <code>srun</code>, <code>sbatch</code> or <code>mpirun</code>. The EAR Library (EARL) is automatically loaded with some applications when EAR is enabled by default.</p>
<p>Check with the <a class="el" href="../../dc/d09/md_EAR_commands.html#ear-info">ear-info</a> command if EARL is <code>on</code>/<code>off</code> by default. If itâ€™s <code>off</code>, use <code>--ear=on</code> option offered by EAR SLURM plug-in to enable it. For other schedulers, a simple prolog/epilog command can be created to provide transparent job submission with EAR and default configuration. The EAR development team had worked also with OAR and PBSPro batch schedulers, but currently there is no any official stable nor supported feature.</p>
<h1><a class="anchor" id="use-cases"></a>
Use cases</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
MPI applications</h2>
<p>EARL is automatically loaded with MPI applications when EAR is enabled by default (check <code>ear-info</code>). EAR supports the utilization of both <code>mpirun</code>/<code>mpiexec</code> and <code>srun</code> commands.</p>
<p>When using <code>sbacth</code>/<code>srun</code> or <code>salloc</code>, <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/mpi-library.html#gs.mufipm">Intel MPI</a> and <a href="https://www.open-mpi.org/">OpenMPI</a> are fully supported. When using specific MPI flavour commands to start applications (e.g., <code>mpirun</code>, <code>mpiexec.hydra</code>), there are some keypoints which you must take account. See <a class="el" href="../../d6/d86/md_User_guide.html#using-mpirunmpiexec-command">next sections</a> for examples and more details.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Hybrid MPI + (OpenMP, CUDA, MKL) applications</h3>
<p>EARL automatically supports this use case. <code>mpirun</code>/<code>mpiexec</code> and <code>srun</code> are supported in the same manner as explained above.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Python MPI applications</h3>
<p>EARL cannot detect automatically MPI symbols when Python is used. On that case, an environment variable used to specify which MPI flavour is provided.</p>
<p>Export <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#ear_load_mpi_version">SLURM_EAR_LOAD_MPI_VERSION</a> environment variable with either <em>intel</em> or <em>open mpi</em> values, e.g., <code>export SLURM_EAR_LOAD_MPI_VERSION="open mpi"</code>, whose are the two MPI implementations 100% supported by EAR.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Running MPI applications on SLURM systems</h3>
<h4>Using srun command</h4>
<p>Running MPI applications with EARL on SLURM systems using <code>srun</code> command is the most straightforward way to start using EAR. All jobs are monitored by EAR and the Library is loaded by default depending on the cluster configuration. To run a job with <code>srun</code> and EARL <b>there is no need to load the EAR module</b>.</p>
<p>Even though it is automatic, there are few <a class="el" href="../../d6/d86/md_User_guide.html#ear-job-submission-flags">flags</a> than can be selected at job submission. They are provided by EAR's SLURM SPANK plug-in. When using SLURM commands for job submission, both Intel and OpenMPI implementations are supported.</p>
<h4><a class="anchor" id="using-mpirunmpiexec-command"></a>
Using Using mpirun/mpiexec command</h4>
<p>To provide an automatic loading of the EAR library, the only requirement from the MPI library is to be coordinated with the scheduler.</p>
<h5>Intel MPI</h5>
<p>Recent versions of Intel MPI offers two environment variables that can be used to guarantee the correct scheduler integrations:</p>
<ul>
<li><code>I_MPI_HYDRA_BOOTSTRAP</code> sets the bootstrap server. It must be set to <em>slurm</em>.</li>
<li><code>I_MPI_HYDRA_BOOTSTRAP_EXEC_EXTRA_ARGS</code> sets additional arguments for the bootstrap server. These arguments are passed to SLURM, and they can be all the same as EAR's SPANK plug-in provides.</li>
</ul>
<p>You can read <a href="https://www.intel.com/content/www/us/en/develop/documentation/mpi-developer-reference-linux/top/environment-variable-reference/hydra-environment-variables.html">here</a> the Intel environment variables guide.</p>
<h5>OpenMPI</h5>
<p>For joining OpenMPI and EAR it is highly recommended to use SLURM's <code>srun</code> command. When using <code>mpirun</code>, as OpenMPI is not fully coordinated with the scheduler, EARL is not automatilly loaded on all nodes. Therefore EARL will be disabled and only basic energy metrics will be reported. To provide support for this workflow, EAR provides <a class="el" href="../../dc/d09/md_EAR_commands.html#erun">erun</a> command. Read the corresponding <a class="el" href="../../d6/d86/md_User_guide.html#openmpi-1">examples section</a> for more information about how to use this command.</p>
<h5>MPI4PY</h5>
<p>To use MPI with Python applications, the EAR Loader cannot automatically detect symbols to classify the application as Intel or OpenMPI. In order to specify it, the user has to define the <code>SLURM_LOAD_MPI_VERSION</code> environment variable with the values <em>intel</em> or <em>open mpi</em>. It is recommended to add in Python modules to make it easy for final users.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Non-MPI applications</h2>
<h3><a class="anchor" id="autotoc_md7"></a>
Python</h3>
<p>Since version 4.1 EAR automatically executes the Library with Python applications, so no action is needed. You must run the application with <code>srun</code> command to pass through the EAR's SLURM SPANK plug-in in order to enable/disable/tuning EAR. See <a class="el" href="../../d6/d86/md_User_guide.html#ear-job-submission-flags">EAR submission flags</a> provided by EAR SLURM integration.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
OpenMP, CUDA and Intel MKL</h3>
<p>To load EARL automatically with non-MPI applications it is required to have it compiled with dynamic symbols and also it must be executed with <code>srun</code> command. For example, for CUDA applications the <code>--cudart=shared</code> option must be used at compile time. EARL is loaded for OpenMP, MKL and CUDA programming models when symbols are dynamically detected.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Other application types or frameworks</h2>
<p>For other programming models or sequential apps not supported by default, EARL can be forced to be loaded by setting <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#ear_loader_application">SLURM_EAR_LOADER_APPLICATION</a> enviroment variable, which must be defined with the application name. For example:</p>
<div class="fragment"><div class="line">#!/bin/bash</div>
<div class="line"> </div>
<div class="line">export SLURM_EAR_LOADER_APPLICATION=my_app</div>
<div class="line">srun my_app</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Using EAR inside Singularity containers</h2>
<p><a href="https://apptainer.org/">Apptainer</a> (formerly Singularity) is an open source technology for containerization. It is widely used in HPC contexts because the level of virtualization it offers enables the access to local services. It allows for geater reproducibility, making the programs less dependant on the environment they are being run on.</p>
<p>An example singularity command could look something like this:</p>
<div class="fragment"><div class="line">singularity exec $IMAGE program</div>
</div><!-- fragment --><p>where <code>IMAGE</code> is an environment variable that contains the path of the Singularity container, and <code>program</code> is the executable to be run in the image.</p>
<p>In order to be able to use EAR inside the container two actions are needed:</p>
<ul>
<li>Binding EAR paths to make them visible in the container.</li>
<li>Exporting some environment variables to the execution environment to make them available during the execution.</li>
</ul>
<p>To bind folders there are two options: (1) using the environment variable <code>SINGULARITY_BIND</code>/<code>APPTAINER_BIND</code> or (2) using the <code>-B</code> flag when running the container. 1 is a comma separated string of pairs of paths <code>[path_1][[:path_2][:perms]]</code> such that <em>path_1</em> in local will be mapped into <em>path_2</em> in the image with the permissions set in <em>perms</em>, which can be <em>r</em> or <em>rw</em>. Specifying <em>path_2</em> and <em>perm</em> is optional. If they are not specified <em>path_1</em> will be bound in the same location.</p>
<p>To make EAR working the following paths sould be added to the binding configuration:</p>
<ul>
<li><code>$EAR_INSTALL_PATH,$EAR_INSTALL_PATH/bin,$EAR_INSTALL_PATH/lib,$EAR_TMP</code></li>
</ul>
<p>You should have an EAR module to have the above environment variables. Contact with your system administrator for more information.</p>
<p>Once paths are deployed, to execute (for example) an OpenMPI application inside a Singularity/Apptainer enabling the EAR Library just the following is needed:</p>
<div class="fragment"><div class="line">module load ear</div>
<div class="line"> </div>
<div class="line">mpirun -np &lt;# processes&gt; singularity exec $IMAGE erun --ear=on --program=&quot;program args&quot;</div>
</div><!-- fragment --><p>A more complete example would look something like this:</p>
<div class="fragment"><div class="line">export IMAGE=[path_to_image]/ubuntu_ompi.sif</div>
<div class="line">export BENCH_PATH=[path_to_benchmark]</div>
<div class="line">export APPTAINER_BIND=&quot;$EAR_INSTALL_PATH:$EAR_INSTALL_PATH:ro,$EAR_TMP:$EAR_TMP:rw&quot;</div>
<div class="line">export APPTAINERENV_EAR_REPORT_ADD=sysfs.so</div>
<div class="line"> </div>
<div class="line">mpirun -np 64 singularity exec $IMAGE $EAR_INSTALL_PATH/bin/erun \</div>
<div class="line">    --ear=on --ear-verbose=1 \</div>
<div class="line">    --program=$BENCH_PATH/bt-mz.D.64</div>
</div><!-- fragment --><p>Note that the example exports <code>APPTAINERENV_EAR_REPORT_ADD</code> to set the environment variable <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#ear-report-add">`EAR_REPORT_ADD`</a> to load <a class="el" href="../../da/df5/md_Report.html#sysfs-report-plugin">`sysfs`</a> report plug-in.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Retrieving EAR data</h1>
<p>As a job accounting and monitoring tool, EARL collects some metrics that you can get to see or know your applications behaviour. The Library is doted with several modules and options to be able to provide different kind of information.</p>
<p>As a very simple hint of your application workload, you can enable EARL verbosity to get loop data at runtime. The information is shown at <em>stderr</em> by default. Read how to set up verbosity at <a class="el" href="../../d6/d86/md_User_guide.html#ear-job-submission-flags">submission time</a> and <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#verbosity">verbosity environment variables</a> provided for a more advanced tunning of this EAR feature.</p>
<p>To get offline job data EAR provides <a class="el" href="../../dc/d09/md_EAR_commands.html#eacct">eacct</a>, a tool to provide the monitored job data stored in the Database. You can request information in different ways, so you can read aggregated job data, per-node or per-loop information among other things. See <a class="el" href="../../d6/d86/md_User_guide.html#eacct-1">eacct usage examples</a> for a better overview of which kind of data <code>eacct</code> provides.</p>
<p>There is another way to get runtime and aggregated data during runtime without the need of calling <code>eacct</code> after the job completion. EAR implements a reporting system mechanism which let developers to add new report plug-ins, so there is an infinit set of ways to report EAR collected data.</p>
<p>Therefore EAR releases come with a fully supported report plug-in (called <em>csv_ts</em>) which basically provides the same runtime and aggregated data reported to the Database in CSV files, directly while the job is running. You can load this plug-in in two ways:</p>
<ol type="1">
<li>By setting <a class="el" href="../../d6/d86/md_User_guide.html#ear-job-submission-flags">--ear-user-db</a> flag at submission time.</li>
<li><a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#ear-report-add">Loading directly the report plug-in</a> through an environment variable: <code>export SLURM_EAR_REPORT_ADD=csv_ts.so</code>.</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Contact with <a href="#" onclick="location.href='mai'+'lto:'+'ear'+'-s'+'upp'+'or'+'t@b'+'sc'+'.es'; return false;">ear-support@bsc.es</a> for more information about report plug-ins. </p>
</blockquote>
<p>You can also request EAR to report <b>events</b> to the <a class="el" href="../../d1/d47/md_EAR_Database.html">Database</a>. They show more details about EARL internal state and can be provided with <code>eacct</code> command. See how to enable <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#report_earl_events">EAR events reporting</a> and which kind of events EAR is reporting.</p>
<p>If your application applies, you can request EAR to report at the end of the execution a <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#ear_get_mpi_stats">summary about its MPI behaviour</a>. The information is provided along two files and is the aggregated data of each process of the application.</p>
<p>Finally, EARL can provide runtime data in the <a href="https://tools.bsc.es/paraver">Paraver</a> trace format. Paraver is a flexible performance analysis tool maintained by the <a href="https://bsc.es/"><em>Barcelona Supercomputing Center</em></a>'s tools team. This tool provides an easy way to visualize runtime data, computing derived metrics and to provide histograms for better of your application behaviour. See on the <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#ear_trace_plugin">environment variables page</a> how to generate Paraver traces.</p>
<blockquote class="doxtable">
<p>&zwj;Contact with <a href="#" onclick="location.href='mai'+'lto:'+'ear'+'-s'+'upp'+'or'+'t@b'+'sc'+'.es'; return false;">ear-support@bsc.es</a> if you want to get more details about how to deal with EAR data with Paraver. </p>
</blockquote>
<h1><a class="anchor" id="ear-job-submission-flags"></a>
EAR job submission flags</h1>
<p>The following EAR options can be specified when running <code>srun</code> and/or <code>sbatch</code>, and are supported with <code>srun</code>/<code>sbatch</code>/<code>salloc</code>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--ear=[on|off]   </td><td class="markdownTableBodyNone">Enables/disables EAR library loading with this job.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--ear-user-db=&lt;filename&gt;   </td><td class="markdownTableBodyNone">Asks the EAR Library to generate a set of CSV files with EARL metrics.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--ear-verbose=[0|1]   </td><td class="markdownTableBodyNone">Specifies the level of verbosity; the default is 0.   </td></tr>
</table>
<p>When using <code>--ear-user-db</code> flag, one file per node is generated with the average node metrics (node signature) and one file with multiple lines per node is generated with runtime collected metrics (loops node signatures). Read <a class="el" href="../../dc/d09/md_EAR_commands.html#eacct">eacct's section</a> in the commands page to know which metrics are reported, as data generated by this flag is the same as the reported (and retrieved later by the command) to the Database.</p>
<p>Verbose messages are placed by default in <em>stderr</em>. For jobs with multiple nodes, <code>ear-verbose</code> option can result in lots of messages mixed at <em>stderr</em>. We recommend to split up SLURM's output (or error) file per-node. You can read SLURM's <a href="https://slurm.schedmd.com/sbatch.html#lbAH">filename pattern specification</a> for more information.</p>
<p>If you still need to have job output and EAR output separated, you can set <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html#earl_verbose_path">SLURM_EARL_VERBOSE_PATH</a> environment variable and one file per node will be generated only with EAR output. The environemnt variable must be set with the path (a directory) where you want the output files to be generated, it will be automatically created if needed.</p>
<blockquote class="doxtable">
<p>&zwj;You can always check the avaiable EAR submission flags provided by EAR's SLURM SPANK plug-in by typing <code>srun --help</code>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md12"></a>
CPU frequency selection</h2>
<p>The <a class="el" href="../../d2/d00/md_Configuration.html#ear_conf">EAR configuration file</a> supports the specification of <em>EAR authorized users</em>, who can ask for a more privileged submission options. The most relevant ones are the possibility to ask for a specific optimisation policy and a specific CPU frequency. </p><blockquote class="doxtable">
<p>&zwj;Contact with sysadmin or helpdesk team to become an authorized user. </p>
</blockquote>
<ul>
<li>The <code>--ear-policy=policy_name</code> flag asks for <em>policy_name</em> policy. Type <code>srun --help</code> to see policies currently installed in your system.</li>
<li>The <code>--ear-cpufreq=value</code> (<em>value</em> must be given in kHz) asks for a specific CPU frequency.</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
GPU frequency selection</h2>
<p>EAR version 3.4 and upwards supports GPU monitoring for NVIDIA devices from the point of view of the application and node monitoring. GPU frequency optimization is not yet supported. <b>Authorized</b> users can ask for a specific GPU frequency by setting the <code>SLURM_EAR_GPU_DEF_FREQ</code> environment variable, giving the desired GPU frequency expressed in kHz. Only one frequency for all GPUs is now supported. </p><blockquote class="doxtable">
<p>&zwj;Contact with sysadmin or helpdesk team to become an authorized user. </p>
</blockquote>
<p>To see the list of available frequencies of the GPU you will work on, you can type the following command: </p><div class="fragment"><div class="line">nvidia-smi -q -d SUPPORTED_CLOCKS</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
srun examples</h2>
<p>Having an MPI application asking for one node and 24 tasks, the following is a simple case of job submission. If EARL is turned on by default, no extra options are needed to load it. To check if it is on by default, load the EAR module and execute the <code>ear-info</code> command. EAR verbose is set to 0 by default, i.e., no EAR messages.</p>
<div class="fragment"><div class="line">srun -J test -N 1 -n 24 --tasks-per-node=24 application</div>
</div><!-- fragment --><p>The following executes the application showing EAR messages, including EAR configuration and node signature in <em>stderr</em>.</p>
<div class="fragment"><div class="line">srun --ear-verbose=1 -J test -N 1 -n 24 --tasks-per-node=24 application</div>
</div><!-- fragment --><p>EARL verbose messages are generated in the standard error. For jobs using more than 2 or 3 nodes messages can be overwritten. If the user wants to have EARL messages in a file the <code>SLURM_EARL_VERBOSE_PATH</code> environment variable must be set with a folder name. One file per node will be generated with EARL messages.</p>
<div class="fragment"><div class="line">export SLURM_EARL_VERBOSE_PATH=logs</div>
<div class="line">srun --ear-verbose=1 -J test -N 1 -n 24 --tasks-per-node=24 application</div>
</div><!-- fragment --><p>The following asks for EARL metrics to be stored in csv file after the application execution. Two files per node will be generated: one with the average/global signature and another with loop signatures. The format of output files is &lt;filename&gt;.&lt;nodename&gt;.time.csv for the global signature and &lt;filename&gt;.&lt;nodename&gt;.time.loops.csv for loop signatures.</p>
<div class="fragment"><div class="line">srun -J test -N 1 -n 24 --tasks-per-node=24 --ear-user-db=filename application</div>
</div><!-- fragment --><p>For EAR <em>authorized users</em>, the following executes the application with a CPU frequency of 2.0GHz:</p>
<div class="fragment"><div class="line">srun --ear-cpufreq=2000000 --ear-policy=monitoring --ear-verbose=1 -J test -N 1 -n 24 --tasks-per-node=24 application</div>
</div><!-- fragment --><p>For <code>--ear-cpufreq</code> to have any effect, you must specify the <code>--ear-policy</code> option even if you want to run your application with the default policy.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
sbatch + EARL + srun</h2>
<p>When using <code>sbatch</code> EAR options can be specified in the same way. If more than one <code>srun</code> is included in the job submission, EAR options can be inherited from <code>sbatch</code> to the different <code>srun</code> instances or they can be specifically modified on each individual <code>srun</code>.</p>
<p>The following example will execute twice the application. Both instances will have the verbosity set to 1. As the job is asking for 10 nodes, we have set the <code>SLURM_EARL_VERBOSE_PATH</code> environment variable set to the <em>ear_log</em> folder. Moreover, the second step will create a set of csv files placed in the <em>ear_metrics</em> folder. The nodename, Job Id and Step Id are part of the filename for a better identification.</p>
<div class="fragment"><div class="line">#!/bin/bash</div>
<div class="line">#SBATCH -N 1</div>
<div class="line">#SBATCH -e test.%j.err</div>
<div class="line">#SBATCH -o test.%j.out</div>
<div class="line">#SBTACH --ntasks=24</div>
<div class="line">#SBATCH --tasks-per-node=24</div>
<div class="line">#SBATCH --cpus-per-task=1</div>
<div class="line">#SBATCH --ear-verbose=1</div>
<div class="line"> </div>
<div class="line">export SLURM_EARL_VERBOSE_PATH=ear_logs</div>
<div class="line"> </div>
<div class="line">srun application</div>
<div class="line"> </div>
<div class="line">mkdir ear_metrics</div>
<div class="line">srun --ear-user-db=ear_metrics/app_metrics application</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
EARL + mpirun</h2>
<h3><a class="anchor" id="autotoc_md18"></a>
Intel MPI</h3>
<p>When running EAR with <code>mpirun</code> rather than <code>srun</code>, we have to specify the utilization of <code>srun</code> as bootstrap. Version 2019 and newer offers two environment variables for bootstrap server specification and arguments.</p>
<div class="fragment"><div class="line">export I_MPI_HYDRA_BOOTSTRAP=slurm</div>
<div class="line">export I_MPI_HYDRA_BOOTSTRAP_EXEC_EXTRA_ARGS=&quot;--ear-policy=monitoring --ear-verbose=1&quot;</div>
<div class="line">mpiexec.hydra -n 10 application</div>
</div><!-- fragment --><h3><a class="anchor" id="openmpi-1"></a>
OpenMPI</h3>
<p>Bootstrap is an Intel(R) MPI option but not an OpenMPI option. For OpenMPI <code>srun</code> must be used for an automatic EAR support. In case OpenMPI with <code>mpirun</code> is needed, EAR offers the <code>erun</code> command, which is a program that simulates all the SLURM and EAR SLURM Plug-in pipeline. You can launch <code>erun</code> with the <code>--program</code> option to specify the application name and arguments.</p>
<div class="fragment"><div class="line">mpirun -n 4 /path/to/erun --program=&quot;hostname --alias&quot;</div>
</div><!-- fragment --><p>In this example, <code>mpirun</code> would run 4 erun processes. Then, <code>erun</code> will launch the application <code>hostname</code> with its alias parameter. You can use as many parameters as you want but the semicolons have to cover all of them in case there are more than just the program name.</p>
<p><code>erun</code> will simulate on the remote node both the local and remote pipelines for all created processes. It has an internal system to avoid repeating functions that are executed just one time per job or node, like SLURM does with its plugins.</p>
<p><b>IMPORTANT NOTE</b> If you are going to launch <code>n</code> applications with <code>erun</code> command through a sbatch job, you must set the environment variable <code>SLURM_STEP_ID</code> to values from <code>0</code> to <code>n-1</code> before each <code>mpirun</code> call. By this way <code>erun</code> will inform the EARD the correct step ID to be stored then to the Database.</p>
<h1><a class="anchor" id="eacct-1"></a>
EAR job Accounting (eacct)</h1>
<p>The <a class="el" href="../../dc/d09/md_EAR_commands.html#eacct">eacct</a> command shows accounting information stored in the EAR DB for jobs (and steps) IDs. The command uses EAR's configuration file to determine if the user running it is privileged or not, as <b>non-privileged users can only access their information</b>. It provides the following options.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Usage examples</h2>
<p>The basic usage of <code>eacct</code> retrieves the last 20 applications (by default) of the user executing it. If a user is <b>privileged</b>, they may see all users applications. The default behaviour shows data from each job-step, aggregating the values from each node in said job-step. If using SLURM as a job manager, a <em>sb</em> (sbatch) job-step is created with the data from the entire execution. A specific job may be specified with <code>-j</code> option.</p>
<div class="fragment"><div class="line">[user@host EAR]$ eacct -j 175966</div>
<div class="line">    JOB-STEP USER       APPLICATION      POLICY NODES AVG/DEF/IMC(GHz) TIME(s)    POWER(W) GBS     CPI   ENERGY(J)    GFLOPS/W IO(MBs) MPI%  G-POW (T/U)   G-FREQ  G-UTIL(G/MEM)</div>
<div class="line"> 175966-sb   user       afid             NP     2     2.97/3.00/---    3660.00    381.51   ---     ---   2792619      ---      ---     ---   ---           ---     ---</div>
<div class="line"> 175966-2    user       afid             MO     2     2.97/3.00/2.39   1205.26    413.02   146.21  1.04  995590       0.1164   0.0     21.0  ---           ---     ---</div>
<div class="line"> 175966-1    user       afid             MT     2     2.62/2.60/2.37   1234.41    369.90   142.63  1.02  913221       0.1265   0.0     19.7  ---           ---     ---</div>
<div class="line"> 175966-0    user       afid             ME     2     2.71/3.00/2.19   1203.33    364.60   146.23  1.07  877479       0.1310   0.0     17.9  ---           ---     ---</div>
</div><!-- fragment --><p>The command shows a pre-selected set of columns, read <code>eacct</code>'s section on the <a class="el" href="../../dc/d09/md_EAR_commands.html">EAR commands page</a>.</p>
<p>For node-specific information, the <code>-l</code> (i.e., long) option provides detailed accounting of each individual node: In addition, <code>eacct</code> shows an additional column: <code>VPI(%)</code> (See the example below). The VPI is meaning the percentage of AVX512 instructions over the total number of instructions.</p>
<div class="fragment"><div class="line">[user@host EAR]$ eacct -j 175966 -l</div>
<div class="line">     JOB-STEP    NODE ID    USER ID    APPLICATION      AVG-F/IMC-F TIME(s)    POWER(s)   GBS        CPI        ENERGY(J)  IO(MBS) MPI%  VPI(%)  G-POW(T/U)    G-FREQ G-UTIL(G/M)</div>
<div class="line">  175966-sb      cmp2506    user       afid              2.97/---   3660.00    388.79     ---        ---        1422970    ---     ---   ---     ---     ---      ---</div>
<div class="line">  175966-sb      cmp2507    user       afid              2.97/---   3660.00    374.22     ---        ---        1369649    ---     ---   ---     ---     ---      ---</div>
<div class="line">  175966-2       cmp2506    user       afid              2.97/2.39  1205.27    423.81     146.06     1.03       510807     0.0     21.2  0.23    ---     ---      ---</div>
<div class="line">  175966-2       cmp2507    user       afid              2.97/2.39  1205.26    402.22     146.35     1.05       484783     0.0     20.7  0.01    ---     ---      ---</div>
<div class="line">  175966-1       cmp2506    user       afid              2.58/2.38  1234.46    374.14     142.51     1.02       461859     0.0     19.4  0.00    ---     ---      ---</div>
<div class="line">  175966-1       cmp2507    user       afid              2.67/2.37  1234.35    365.67     142.75     1.03       451362     0.0     20.0  0.01    ---     ---      ---</div>
<div class="line">  175966-0       cmp2506    user       afid              2.71/2.19  1203.32    371.76     146.25     1.08       447351     0.0     17.9  0.01    ---     ---      ---</div>
<div class="line">  175966-0       cmp2507    user       afid              2.71/2.19  1203.35    357.44     146.21     1.05       430128     0.0     17.9  0.01    ---     ---      ---</div>
</div><!-- fragment --><p>If EARL was loaded during an application execution, runtime data (i.e., EAR loops) may be retrieved by using <code>-r</code> flag. You can still filter the output by Job (and Step) ID.</p>
<p>Finally, to easily transfer <code>eacct</code>â€™s output, <code>-c</code> option saves the requested data in CSV format. Both aggregated and detailed accountings are available, as well as filtering. When using along with <code>-l</code> or <code>-r</code> options, all metrics stored in the EAR Database are given. Please, read the <a class="el" href="../../dc/d09/md_EAR_commands.html">commands section page</a> to see which of them are available.</p>
<div class="fragment"><div class="line">[user@host EAR]$ eacct -j 175966.1 -r</div>
<div class="line">    JOB-STEP      NODE ID    ITER.  POWER(W) GBS      CPI      GFLOPS/W TIME(s)  AVG_F IMC_F IO(MBS) MPI%  G-POWER(T/U) G-FREQ   G-UTIL(G/MEM)</div>
<div class="line"> 175966-1         cmp2506    21     360.6    115.8    0.838    0.086    1.001    2.58  2.30  0.0     11.6  0.0   /   0.0  0.00     0%/0%</div>
<div class="line"> 175966-1         cmp2507    21     333.7    118.4    0.849    0.081    1.001    2.58  2.32  0.0     12.0  0.0   /   0.0  0.00     0%/0%</div>
<div class="line"> 175966-1         cmp2506    31     388.6    142.3    1.010    0.121    1.113    2.58  2.38  0.0     19.7  0.0   /   0.0  0.00     0%/0%</div>
<div class="line"> 175966-1         cmp2507    31     362.8    142.8    1.035    0.130    1.113    2.59  2.37  0.0     19.5  0.0   /   0.0  0.00     0%/0%</div>
<div class="line"> 175966-1         cmp2506    41     383.3    143.2    1.034    0.124    1.114    2.58  2.38  0.0     19.6  0.0   /   0.0  0.00     0%/0%</div>
</div><!-- fragment --><div class="fragment"><div class="line">[user@host EAR]$ eacct -j 175966 -c test.csv</div>
<div class="line"> Successfully written applications to csv. Only applications with EARL will have its information properly written.</div>
<div class="line"> </div>
<div class="line">[user@host EAR]$ eacct -j 175966.1 -c -l test.csv</div>
<div class="line"> Successfully written applications to csv. Only applications with EARL will have its information properly written.</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
Job energy optimization: EARL policies</h1>
<p>The core component of EAR at the user's job level is the EAR Library (EARL). The Library deals with job monitoring and is the component which implements and applies optimization policies based on monitored workload.</p>
<p>We highly recommend you to read <a class="el" href="../../df/dde/md_Architecture.html#the-ear-library">EARL</a> documentation and also how energy policies work in order to better understand what is doing the Library internally, so you will can explore easily all features (e.g., tunning variables, collecting data) EAR offers to the end-user so you will have more knowledge about how much resources your application consumes and how to correlate with its computational characteristics. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
