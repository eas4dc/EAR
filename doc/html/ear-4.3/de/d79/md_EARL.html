<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EAR: The EAR Library</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">EAR<span id="projectnumber">&#160;4.3</span>
   </div>
   <div id="projectbrief">Reference Manual</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('de/d79/md_EARL.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">The EAR Library </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md58">Overview</a></li>
<li class="level1"><a href="#autotoc_md59">Configuration</a></li>
<li class="level1"><a href="#autotoc_md60">Usage</a></li>
<li class="level1"><a href="#earl-policies">Policies</a><ul><li class="level2"><a href="#autotoc_md61">Plugin min_energy</a></li>
<li class="level2"><a href="#autotoc_md62">Plugin min_time</a></li>
</ul>
</li>
<li class="level1"><a href="#ear-api">EAR API</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md58"></a>
Overview</h1>
<p>The EAR Library is the core of the EAR package. The EARL offers a lightweight and simple solution to select the optimal frequency for applications at runtime.</p>
<p>EARL is dynamically loaded next to the running applications by the <a class="el" href="../../dc/dc0/ear-loader.html#md_EAR_Loader">EAR Loader</a>. The loader detects whether the application is MPI or not. In case it is MPI, it also detects whether it is Intel or OpenMPI. Moreover, in the case of MPI, it intercepts the MPI symbols through the PMPI interface, and next symbols are saved in order to provide compatibility with MPI or other profiling tools. The EAR library is divided in several stages summarized in the following picture:</p>
<div class="image">
<img src="../../stack.png" alt=""/>
</div>
    <ol type="1">
<li>Automatic <b>detection</b> of application outer loops. This is done by intercepting MPI calls and invoking the Dynamic Application Iterative Structure detector algorithm. <b>DynAIS</b> is highly optimized for new Intel architectures, reporting low overhead. For non-MPI applications, EAR implements a time-guided approach.</li>
<li>Computation of the <b>application signature</b>. Once DynAIS starts reporting iterations for the outer loop, EAR starts to compute the application signature. This signature includes: iteration time, DC power consumption, bandwidth, cycles, instructions, etc. Since the DC power measurements error highly depends on the hardware, EAR automatically detects the hardware characteristics and sets a minimum time to compute the signature in order to minimize the average error.</li>
</ol>
<div class="image">
<img src="../../models.png" alt=""/>
</div>
    <p>The loop signature is used to <b>classify the application activity</b> in different phases. The current EAR version supports the following phases for: IO bound, CPU computation and GPU idle, CPU busy waiting and GPU computing, CPU-GPU computation, and CPU computation (for CPU only nodes). For phases including CPU computation, the optimization policy is applied. For other phases, the EAR library implements some predefined CPU/Memory/GPU frequency settings.</p>
<ol type="1">
<li><b>Power and performance projection</b>. EAR has its own performance and power models which requires the application and the system signatures as an input. The system signature is a set of coefficients characterizing each node in the system. They are computed during the learning phase at the EAR configuration step. EAR projects the power used and computing time (performance) of the running application for all the available frequencies in the system. These models are applied to CPU metrics and projects CPU performance and power when varying the CPU frequency. Using these projections the optimization policy can select the optimal CPU memory.</li>
</ol>
<div class="image">
<img src="../../projections.png" alt=""/>
</div>
    <ol type="1">
<li><b>Apply</b> the selected energy optimization policy. EAR includes two power policies to be selected at runtime: <em>minimize time to solution</em> and <em>minimize energy to solution</em>, if permitted by the system administrator. At this point, EAR executes the power policy, using the projections computed in the previous phase, and selects the optimal frequency for an application and its particular run. An additional policy, <em>monitoring only</em> can also be used, but in this case no changes to the running frequency will be made but only the computation and storage of the application signature and metrics will be done. The short version of the names is used when submitting jobs (min_energy, min_time, monitoring). Current policies already includes memory frequency selection but in this case it is not based on models, it is a guided search. Check in your installation in the memory frequency optimization is enabled by default. In case the application is MPI, the policies already classifies the processes as balanced or unbalanced. In case they are unbalanced, a per-process CPU frequency is applied.</li>
</ol>
<p>Some specific configurations are modified when jobs are executed sharing nodes with other jobs. For example the memory frequency optiization is disabled. See section <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html">environment variables page</a> for more information on how to tune the EAR library optimization using environment variables.</p>
<h1><a class="anchor" id="autotoc_md59"></a>
Configuration</h1>
<p>The EAR Library uses the <code>$(EAR_ETC)/ear.conf</code> file to be configured. Please visit the <a class="el" href="../../d2/d00/md_Configuration.html#earl-configuration">EAR configuration file page</a> for more information about the options of EARL and other components.</p>
<p>The library receives its specific settings through a shared memory regions initialized by <a class="el" href="../../d5/d80/md_EARD.html">EARD</a>.</p>
<h1><a class="anchor" id="autotoc_md60"></a>
Usage</h1>
<p>For information on how to run applications alongside with EARL read the <a class="el" href="../../d6/d86/md_User_guide.html">User guide</a>. Next section contains more information regarding EAR's optimisation policies.</p>
<h1><a class="anchor" id="earl-policies"></a>
Policies</h1>
<p>EAR offers three energy policies plugins: <code>min_energy</code>, <code>min_time</code> and <code>monitoring</code>. The last one is not a power policy, is used just for application monitoring where CPU frequency is not modified (neither memory or GPU frequency). For application analysis <code>monitoring</code>can be used with specific CPU, memory and/or GPU frequencies.</p>
<p>The energy policy is selected by setting the <code>--ear-policy=policy</code> option when submitting a SLURM job. A policy parameter, which is a particular value or threshold depending on the policy, can be set using the flag <code>--ear-policy-th=value</code>. Its default value is defined in the configuration file, for more information check the <a class="el" href="../../d2/d00/md_Configuration.html">configuration page</a> for more information.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Plugin min_energy</h2>
<p>The goal of this policy is to minimise the energy consumed with a limit to the performance degradation. This limit is is set in the SLURM <code>--ear-policy-th</code> option or the configuration file. The <code>min_energy</code> policy will select the optimal frequency that minimizes energy enforcing (performance degradation &lt;= parameter). When executing with this policy, applications starts at default frequency(specified at ear.conf).</p>
<div class="fragment"><div class="line">PerfDegr = (CurrTime - PrevTime) / (PrevTime)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
Plugin min_time</h2>
<p>The goal of this policy is to improve the execution time while guaranteeing a minimum ratio between performance benefit and frequency increment that justifies the increased energy consumption from this frequency increment. The policy uses the SLURM parameter option mentioned above as a minimum efficiency threshold.</p>
<p><b>Example:</b> if <code>--ear-policy-th=0.75</code>, EAR will prevent scaling to upper frequencies if the ratio between performance gain and frequency gain do not improve at least 75% (PerfGain &gt;= (FreqGain * threshold).</p>
<div class="fragment"><div class="line">PerfGain=(PrevTime-CurrTime)/PrevTime</div>
<div class="line">FreqGain=(CurFreq-PrevFreq)/PrevFreq</div>
</div><!-- fragment --><p>When launched with <code>min_time</code> policy, applications start at a default frequency (defined at <code>ear.conf</code>). Check the <a class="el" href="../../d2/d00/md_Configuration.html">configuration page</a> for more information.</p>
<p><b>Example:</b> given a system with a nominal frequency of 2.3GHz and default P_STATE set to 3, an application executed with <code>min_time</code> will start with frequency <code>F\\\[i\\\]=2.0Ghz</code> (3 P_STATEs less than nominal). When application metrics are computed, the library will compute performance projection for <code>F\\\[i+1\\\]</code> and will compute the performance_gain as shown in the Figure 1. If performance gain is greater or equal than threshold, the policy will check with the next performance projection <code>F\\\[i+2\\\]</code>. If the performance gain computed is less than threshold, the policy will select the last frequency where the performance gain was enough, preventing the waste of energy.</p>
<div class="image">
<img src="../../min_time_example.png" alt=""/>
</div>
    <p>Figure 1: <code>min_time</code> uses the threshold value as the minimum value for the performance gain between <code>F\\\[i\\\]</code> and <code>F\\\[i+1\\\]</code>.</p>
<h1><a class="anchor" id="ear-api"></a>
EAR API</h1>
<p>EAR offers a user API for applications. The current EAR version only offers two functions, one to read the accumulated energy and time and another to compute the difference between the two measurements.</p>
<ul>
<li><code>int ear_connect()</code></li>
<li><code>int ear_energy(unsigned long \\\*energy_mj, unsigned long \\\*time_ms)</code></li>
<li><code>void ear_energy_diff(unsigned long ebegin, unsigned long eend, unsigned long \\\*ediff, unsigned long tbegin, unsigned long tend, unsigned long \\\*tdiff)</code></li>
<li><code>int ear_set_cpufreq(cpu_set_t \\\*mask,unsigned long cpufreq);</code></li>
<li><code>int ear_set_gpufreq(int gpu_id,unsigned long gpufreq)</code></li>
<li><code>int ear_set_gpufreq_list(int num_gpus,unsigned long \\\*gpufreqlist)</code></li>
<li><code>void ear_disconnect()</code></li>
</ul>
<p>EAR's header file and library can be found at $EAR_INSTALL_PATH/include/ear.h and $EAR_INSTALL_PATH/lib/libEAR_api.so respectively. The following example reports the energy, time, and average power during that time for a simple loop including a <code>sleep(5)</code>.</p>
<div class="fragment"><div class="line">#define _GNU_SOURCE</div>
<div class="line">#include &lt;ear.h&gt;</div>
<div class="line"> </div>
<div class="line">int main(int argc,char *argv[])</div>
<div class="line">{</div>
<div class="line">  unsigned long e_mj=0,t_ms=0,e_mj_init,t_ms_init,e_mj_end,t_ms_end=0;</div>
<div class="line">  unsigned long ej,emj,ts,tms,os,oms;</div>
<div class="line">  unsigned long ej_e,emj_e,ts_e,tms_e,os_e,oms_e;</div>
<div class="line">  int i=0;</div>
<div class="line">  struct tm *tstamp,*tstamp2,*tstamp3,*tstamp4;</div>
<div class="line">  char s[128],s2[128],s3[128],s4[128];</div>
<div class="line">  </div>
<div class="line">  /* Connecting with ear */</div>
<div class="line">  if (ear_connect()!=EAR_SUCCESS)</div>
<div class="line">  {</div>
<div class="line">    printf(&quot;error connecting eard\n&quot;);</div>
<div class="line">    exit(1);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  /* Reading energy */</div>
<div class="line">  if (ear_energy(&amp;e_mj_init,&amp;t_ms_init)!=EAR_SUCCESS)</div>
<div class="line">  {</div>
<div class="line">    printf(&quot;Error in ear_energy\n&quot;);</div>
<div class="line">  }</div>
<div class="line">  while(i&lt;5)</div>
<div class="line">  {</div>
<div class="line">    sleep(5);</div>
<div class="line"> </div>
<div class="line">    /* READING ENERGY */</div>
<div class="line">    if (ear_energy(&amp;e_mj_end,&amp;t_ms_end)!=EAR_SUCCESS)</div>
<div class="line">    {</div>
<div class="line">      printf(&quot;Error in ear_energy\n&quot;);</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">      ts=t_ms_init/1000;</div>
<div class="line">      ts_e=t_ms_end/1000;</div>
<div class="line">      tstamp=localtime((time_t *)&amp;ts);</div>
<div class="line">      strftime(s, sizeof(s), &quot;%c&quot;, tstamp);</div>
<div class="line">              tstamp2=localtime((time_t *)&amp;ts_e);</div>
<div class="line">              strftime(s2, sizeof(s), &quot;%c&quot;, tstamp2);</div>
<div class="line"> </div>
<div class="line">      printf(&quot;Start time %s End time %s\n&quot;,s,s2);</div>
<div class="line">      ear_energy_diff(e_mj_init,e_mj_end, &amp;e_mj, t_ms_init,t_ms_end,&amp;t_ms);</div>
<div class="line">      printf(&quot;Time consumed %lu (ms), energy consumed %lu(mJ), </div>
<div class="line">             Avg power %lf(W)\n&quot;,t_ms,e_mj,(double)e_mj/(double)t_ms);</div>
<div class="line">      e_mj_init=e_mj_end;</div>
<div class="line">      t_ms_init=t_ms_end;</div>
<div class="line">    }</div>
<div class="line">    i++;</div>
<div class="line">  }</div>
<div class="line">  ear_disconnect();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
