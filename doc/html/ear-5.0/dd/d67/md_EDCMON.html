<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EAR: Energy Data Center Monitor</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">EAR<span id="projectnumber">&#160;5.0</span>
   </div>
   <div id="projectbrief">Reference Manual</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dd/d67/md_EDCMON.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Energy Data Center Monitor </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Energy Data Center Monitor is a new EAR service for Data Center monitoring. In particular, it targets elements different than computational nodes which are already monitored by the EARD running in compute nodes. However, whereas the EARDs monitor (among others) DC node power, the EDCMON service targets (eventhough it's not limited to) AC power. Because of that reason, the EDCMON main goal is to include all the power consumer components in a Data Center (Compute nodes, Network, Storage, Management).</p>
<p>EDCMON is 100% configurable and extensible since it uses an EAR framework named Plugin Manager which allows to load as many plugins as needed, which specific frequencies , dependencies among them and to share data between them. These plugins can communicate with each other through a <b>tag</b> (naming) system. The tag is a free text specified in the plugin code and is used as reference to specify dependencies, data sharing etc.</p>
<h1><a class="anchor" id="autotoc_md147"></a>
The EDCMON executable</h1>
<p>EDCMON parameters are:</p>
<div class="fragment"><div class="line">Usage: ./edcmon [OPTIONS]</div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">    --plugins    List of comma separated plugins to load.</div>
<div class="line">    --paths      List of comma separated priority paths to search plugins.</div>
<div class="line">    --verbose    Show how the things are going internally.</div>
<div class="line">    --silence    Hide messages returned by plugins.</div>
<div class="line">    --monitor    Period at which the plugin wake ups for monitoring. Def=100 ms </div>
<div class="line">    --relax      Period to be used during low monitoring periods. Def=100 ms  </div>
<div class="line">    --help       If you see it you already typed --help.</div>
</div><!-- fragment --><p>This is an example of the executable arguments and its format:</p>
<div class="fragment"><div class="line">edcmon --monitor=1000 --relax=1000 --plugins=nodesensors.so:30000+nodesensors_report.so:30000:nodesensor_log+nodesensors_alerts.so:30000:log --verbose</div>
</div><!-- fragment --><p>This example shows the default configuration used by EAR when the edcmon service is deployed. This case configures a monitoring period of 1 second and it loads three plugins (separated by character +):</p>
<ul>
<li>nodesensors: monitoring plugin based on Lenovo Confluent software. Reads specified sensors every 30 seconds. Exposes "nodesensors" tag.</li>
<li>nodesensors_report: a reporting plugin for nodesensors plugin. Depends on "nodesensors" tag and uses its data. It is executed every 30 secs. The "nodesensor_log" is a parameter indicating the report plugin to use. Exposes "nodesensors_report" tag.</li>
<li>nodesensors_alerts: An alerting plugin depending on "nodesensors" tag and using the data produced by it. Executed every 30 secs. Exposes the "nodesensors_alerts" tag. The argument "log" indicates the approach to report alerts.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;Plugins are installed in $EAR_INSTALL_PATH/lib/plugins/monitoring folder </p>
</blockquote>
<div class="fragment"><div class="line">./edcemon --plugins=metrics.so:2000+periodic_metrics.so:4000 --paths=path/to/plugins1:path/to/plugins2</div>
</div><!-- fragment --><p><b>The list of plugins to load</b> contains also their calling time in milliseconds. Its main periodic action (PA) function will be called once that time has passed. But that variable is not mandatory, because some plugins may not have defined a PA function and only act as receiver of other plugin data. In that case these receiving functions will be called once the shared data of other plugin is ready. Or maybe you don't want Plugin Manager to call your PA function in that moment.</p>
<p>Also, additional colons can be provided to pass information to a plugin during its initialization:</p>
<div class="fragment"><div class="line">./edcmon --plugins=metrics.so:2000+periodic_metrics.so:4000:config_message1:config_message2 --paths=path/to/plugins1:path/to/plugins2</div>
</div><!-- fragment --><p>You can send N configuration messages to your plugin initialization function which will alter its behaviour. You can avoid the time variable or write 0 instead:</p>
<div class="fragment"><div class="line">./edcmon --plugins=metrics.so:2000+periodic_metrics.so:0000:config_message1:config_message2 --paths=path/to/plugins1:path/to/plugins2</div>
<div class="line"> </div>
<div class="line">./edcmon --plugins=metrics.so:2000+periodic_metrics.so:config_message1:config_message2 --paths=path/to/plugins1:path/to/plugins2</div>
</div><!-- fragment --><p>Plugins also have <b>dependencies</b>. It means that a plugin may depend on the actions or data shared by other plugins. A dependency is written in a string in the compiled binary itself, so you don't have to load it manually. It will be loaded automatically and its calling time could be the dependent plugin time (if specified in the binary). But if you want to set a specific calling time you have to load it manually and set the time you want. If a dependency is hard (which is specified in the string), a failure in the required plugin will disable the dependent plugin.</p>
<p>Plugins also have <b>priorities</b>. If a plugin A is a dependency of plugin B, the plugin A will be called before. If a Plugin B was written before plugin A in the <code>--plugins</code> parameter, A will be called before, because these cases are contemplated in the dependency system algorithmics.</p>
<h1><a class="anchor" id="autotoc_md148"></a>
EDCMON plugins</h1>
<p>Even though in the plugins folder there are other plugins available (listed at the end of this page), these are the plugins specifics for Data center monitoring.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Plugin   </th><th class="markdownTableHeadNone">Information    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">nodesensors   </td><td class="markdownTableBodyNone">Reads confluent power sensors    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">nodesensors_report   </td><td class="markdownTableBodyNone">Reports power readings explosed by nodesesors    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">nodesensors_alter   </td><td class="markdownTableBodyNone">Checks limits and executes actions based on nodesensors   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md149"></a>
Creating new plugins</h1>
<p>As previously said, the plugin periodic functions have to have concrete name. These functions names and arguments are the following:</p>
<div class="fragment"><div class="line">void  up_get_tag         (cchar **tag, cchar **tags_deps)</div>
<div class="line">char *up_action_init     (cchar *tag, void **data_alloc, void *data)</div>
<div class="line">char *up_action_periodic (cchar *tag, void *data)</div>
<div class="line">char *up_post_data       (cchar *msg, void *data)</div>
</div><!-- fragment --><p>The function <code>up_get_tag</code> is in charge of returning the plugin own tag and its dependency tags. A tag matches the name of the shared object file (without the extension). As seid, the dependency tags allows the Plugin Manager to search and open the tagged plugins automatically. The format is a tag list sepparated by plus signs. Example:</p>
<div class="fragment"><div class="line">void up_get_tag(cchar **tag, cchar **tags_deps)</div>
<div class="line">{</div>
<div class="line">    *tag = &quot;some_test&quot;;</div>
<div class="line">    *tags_deps = &quot;dependency1+!dependency2&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>If a dependency tag starts with some symbols</b> such as exclamation mark '!', it means that dependency is mandatory for the loading plugin, and in case it is not resolved the loading plugin will be disabled. The symbol '&lt;' tells the Plugin Manager to inherit the timing of the dependant plugin.</p>
<p>The function <code>up_action_periodic()</code> or PA is the core function to perform actions and share data. It receives a tag and a pointer to the data associated with that tag. The received tag could be the self tag or the tag of other plugins. The plugin PA function will be called with its own tag and data when the specified time in <code>--plugins</code> argument has passed, or with other plugin tag and data after that plugin has called its own PA function with its own tag.</p>
<p>Examples of PA function types: </p><div class="fragment"><div class="line">char *up_action_periodic(cchar *tag, void *data)</div>
<div class="line">{</div>
<div class="line">    if (is_tag(&quot;tag2&quot;)) {</div>
<div class="line">        type2_t *d = (type2_t *) data;</div>
<div class="line">        // work</div>
<div class="line">    }</div>
<div class="line">    return NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">char *up_action_periodic_tag1(cchar *tag, void *data)</div>
<div class="line">{</div>
<div class="line">    type1_t *d = (type1_t *) data;</div>
<div class="line">    // work</div>
<div class="line">    return NULL;</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see, you can define a generic <code>up_action_periodic()</code> function or one with a suffixed tag. A suffixed function will be called only when a plugin whose tag matches the function tag suffix. If you define just a generic version of the function, take into the account that you have to distinguish between tags. The macro <code>is_tag</code> will help you to do this and maintain your code clean and verbose.</p>
<p>The returning char is a message that Plugin Manager will print in case is not NULL. You can add some modifiers at the beginning of the message:</p>
<ul>
<li><code>[D]</code> disables the plugin. It also re-activates the dependency system and could disable dependant plugins.</li>
<li><code>[=]</code> pauses the periodic call.</li>
<li><code>[X]</code> closes the Plugin Manager main thread.</li>
</ul>
<p>The <code>up_action_init()</code> function works the same, it can receive the own plugin tag o other plugin tag. It is called one time before calling any PA function and can be used to allocate and initialize data.</p>
<div class="fragment"><div class="line">static mydata_t mydata;</div>
<div class="line"> </div>
<div class="line">char *up_action_periodic_mytag (cchar *tag, void **data_alloc, void *data)</div>
<div class="line">{</div>
<div class="line">    *data_alloc = &amp;mydata;</div>
<div class="line">    return &quot;I have been initialized and mydata will be shared among the loaded plugins&quot;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">char *up_action_periodic_tag2 (cchar *tag, void **data_alloc, void *data)</div>
<div class="line">{</div>
<div class="line">    tag2_type_t var = (tag2_type_t) data;</div>
<div class="line">    return &quot;Now I know that tag2 plugin has been initialized&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><p>When an initialization function is called and receives its own plugin tag, the <code>data_alloc</code> double pointer serves as pointer to the data that self plugin wants to share with other plugins, so it is responsible to allocate the data and set the address pointer. When an initialization function is called and receives other plugin tag, the <code>data_alloc</code> variable is NULL and <code>data</code> parameter points to the shared data newly initialized by their own plugin, which is the same data referenced in the PA function.</p>
<p>The <b>configuration</b> string mentioned in EDCMON executable is also received when the initialization function is called with own plugin tag using the <code>data</code> parameter, and can be retrieved as a list of arguments:</p>
<div class="fragment"><div class="line">static mydata_t mydata;</div>
<div class="line"> </div>
<div class="line">char *up_action_periodic_mytag (cchar *tag, void **data_alloc, void *data)</div>
<div class="line">{</div>
<div class="line">    char **args = (char **) data;</div>
<div class="line">    *data_alloc = &amp;mydata;</div>
<div class="line">    if (args != NULL) {</div>
<div class="line">        if (strcmp(args[0], &quot;i_want_to_say_hello&quot;) == 0) {</div>
<div class="line">             printf(&quot;Hello!\n&quot;);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    return &quot;I have been initialized and mydata will be shared among the loaded plugins&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The final pipeline is: </p><div class="fragment"><div class="line">1) up_get_tag (all plugins)</div>
<div class="line">2) up_action_init (all plugins)</div>
<div class="line">3) up_action_periodic (all_plugins)</div>
<div class="line">4) up_action_periodic (the plugins whose time has passed, and then the plugins which depends on their data)</div>
<div class="line"> </div>
<div class="line">PA example, if B and C depends on A in --plugins=A.so:4000+B.so:3000+C.so:4000</div>
<div class="line"> 1) A up_action_periodic will be called with &#39;A&#39; tag.</div>
<div class="line"> 2) B up_action_periodic will be called with &#39;A&#39; tag.</div>
<div class="line"> 3) C up_action_periodic will be called with &#39;A&#39; tag.</div>
<div class="line"> 4) B up_action_periodic will be called with &#39;B&#39; tag.</div>
<div class="line"> 5) C up_action_periodic will be called with &#39;C&#39; tag.</div>
<div class="line"> 6) After 3 seconds, B up_action_periodic will be called with &#39;B&#39; tag.</div>
<div class="line"> 7) After 4 seconds, A up_action_periodic will be called with &#39;A&#39; tag.</div>
<div class="line"> 8) After 4 seconds, B up_action_periodic will be called with &#39;A&#39; tag.</div>
<div class="line"> 9) After 4 seconds, C up_action_periodic will be called with &#39;A&#39; tag.</div>
<div class="line">10) After 6 seconds, B up_action_periodic will be called with &#39;B&#39; tag.</div>
<div class="line">11) After 8 seconds, A up_action_periodic will be called with &#39;A&#39; tag.</div>
<div class="line">12) And so on... </div>
</div><!-- fragment --><p>Finally, <code>up_post_data()</code> allows to receive external data to the plugins. In example, if Plugin Manager is being used by the EARD, when a job starts you could send a message to the framework containing the job and step IDs. By now you can distinguish the messages by <code>is_msg</code> macro. Maybe in the near future we implement the suffix system too.</p>
<h2><a class="anchor" id="autotoc_md150"></a>
Helper macros</h2>
<p>The following helper macros to define the functions and maintain your plugins updated in case of a change in some function. They can be found in plugin_manager.h:</p>
<div class="fragment"><div class="line">#define declr_up_get_tag()               void   up_get_tag                 (cchar **tag, cchar **tags_deps)</div>
<div class="line">#define declr_up_action_init(suffix)     char * up_action_init##suffix     (cchar *tag, void **data_alloc, void *data)</div>
<div class="line">#define declr_up_action_periodic(suffix) char * up_action_periodic##suffix (cchar *tag, void *data)</div>
<div class="line">#define declr_up_post_data()             char * up_post_data               (cchar *msg, void *data)</div>
</div><!-- fragment --><p>An example of the <code>up_action_periodic()</code>: Examples of action_periodic function types: </p><div class="fragment"><div class="line">declr_up_action_periodic(_tag1)</div>
<div class="line">{</div>
<div class="line">    type1_t *d = (type1_t *) data;</div>
<div class="line">    // work</div>
<div class="line">    return NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">declr_up_action_periodic()</div>
<div class="line">{</div>
<div class="line">    if (is_tag(&quot;tag2&quot;)) {</div>
<div class="line">        type2_t *d = (type2_t *) data;</div>
<div class="line">        // work</div>
<div class="line">    }</div>
<div class="line">    return NULL;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md151"></a>
Plugin Manager functions</h1>
<p>By now these are the functions of the framework:</p>
<div class="fragment"><div class="line">// Init as main binary function</div>
<div class="line">int plugin_manager_main(int argc, char *argv[]);</div>
<div class="line"> </div>
<div class="line">// Init as a component of a binary</div>
<div class="line">int plugin_manager_init(char *files, char *paths);</div>
<div class="line"> </div>
<div class="line">// Closes Plugin Manager main thread.</div>
<div class="line">void plugin_manager_close();</div>
<div class="line"> </div>
<div class="line">// Wait until Plugin Manager exits.</div>
<div class="line">void plugin_manager_wait();</div>
<div class="line"> </div>
<div class="line">// Asking for an action. Intended to be called from plugins.</div>
<div class="line">void *plugin_manager_action(cchar *tag);</div>
<div class="line"> </div>
<div class="line">// Passing data to plugins. Intended to be called outside PM.</div>
<div class="line">void plugin_mananger_post(cchar *msg, void *data);</div>
</div><!-- fragment --><p>The <code>plugin_manager_main()</code> receives the program arguments (argc and argv), in which is included <code>--plugins</code>. You can also call <code>plugin_manager_init()</code> if you prefer the list of plugins and search paths separately (but in the same format). <code>plugin_manager_action()</code> calls the PA function of the plugin whose tag is referenced, it can be useful in some contexts when a plugin prefers to call a required plugin manually. Finally <code>plugin_manager_wait()</code> waits until the Plugin Manager main thread is closed.</p>
<h2><a class="anchor" id="autotoc_md152"></a>
Other plugins already available</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Plugin   </th><th class="markdownTableHeadNone">Information    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">conf   </td><td class="markdownTableBodyNone">Reads ear.conf and shares its data with other plugins.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dummy   </td><td class="markdownTableBodyNone">Just an example.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eardcon   </td><td class="markdownTableBodyNone">Connects with EARD. Saves other plugins to do that.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel_cl   </td><td class="markdownTableBodyNone">An OpenCL kernel test.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kernel_cuda   </td><td class="markdownTableBodyNone">A CUDA kernel test.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">keyboard   </td><td class="markdownTableBodyNone">A keyboard input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">management   </td><td class="markdownTableBodyNone">Initializes all management APIs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">management_viewer   </td><td class="markdownTableBodyNone">Views all management information.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">metrics   </td><td class="markdownTableBodyNone">Initializes and read all metrics APIs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">metrics_viewer   </td><td class="markdownTableBodyNone">Views all metrics readings.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">periodic_metrics   </td><td class="markdownTableBodyNone">Receives metrics and computes a periodic_metric.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">test_cpufreq   </td><td class="markdownTableBodyNone">A CPUFreq test.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">test_gpu   </td><td class="markdownTableBodyNone">Initializes and read the GPU API.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md153"></a>
FAQ</h1>
<ul>
<li><b>Can I load the same plugin twice?</b> No.</li>
<li><b>Is the tag mandatory value?</b> Yes, all the plugins require a tag.</li>
<li><b>And the dependency tags?</b> Can be set to NULL if the plugin does not have any dependency.</li>
<li><b>Do I have to specify the time of a plugin in the dependency list?</b> No, is not recommended. A plugin which is loaded by the dependency list instead using the <code>--plugins</code> parameter inherits the dependent plugin time if using the special character '&lt;' at the beginning of the string.</li>
<li><b>If none of the dependencies are resolved, the plugin periodic function will be called anyways?</b> Depends if some of the dependencies are mandatory, specified by the exclamation mark (!).</li>
<li><b>What happens if a plugin has periodic time specified but haven't defined a periodic function?</b> If there is no periodic function, nothing will be called.</li>
<li><b>Do I have to define all the API functions in the plugin?</b> No, only those necessary for the correct plugin functionality. The <code>get_tag</code> function is the exception because the tag is a mandatory value.</li>
<li><b>Can <code>action_init</code> function be defined but <code>action_periodic</code> not?</b> Yes. Sometimes you want to perform an action just once and you can do it in the init function. In example, the job of the plugin <code>conf.so</code> is to read <code>ear.conf</code> and pass the configuration structure to the rest of loading plugins.</li>
<li><b>For a plugin which does not allocate data, is its periodic function called?</b> Yes, if it's defined. But the NULL value in the allocated data pointer disallows any information exchange, so periodic function of other plugins wont be called.</li>
<li><b>If a plugin has defined the a function <code>action_periodic_tagX</code> for the tag <code>tagX</code>, but also the general <code>action_periodic</code>, which of the two would be called?</b> If defined a suffixed function, that tagged version will be called. For the rest of the tags the general <code>action_periodic</code>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
