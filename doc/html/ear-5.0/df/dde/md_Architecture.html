<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EAR: Architecture</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">EAR<span id="projectnumber">&#160;5.0</span>
   </div>
   <div id="projectbrief">Reference Manual</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('df/dde/md_Architecture.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Architecture </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ear-node-manager">EAR Node Manager</a><ul><li class="level2"><a href="#autotoc_md61">Overview</a></li>
<li class="level2"><a href="#autotoc_md62">Requirements</a></li>
<li class="level2"><a href="#autotoc_md63">Configuration</a></li>
<li class="level2"><a href="#autotoc_md64">Execution</a></li>
<li class="level2"><a href="#autotoc_md65">Reconfiguration</a></li>
</ul>
</li>
<li class="level1"><a href="#ear-database-manager">EAR Database Manager</a><ul><li class="level2"><a href="#autotoc_md66">Configuration</a></li>
<li class="level2"><a href="#autotoc_md67">Execution</a></li>
</ul>
</li>
<li class="level1"><a href="#ear-global-manager">EAR Global Manager (System power manager)</a><ul><li class="level2"><a href="#autotoc_md68">Power capping</a></li>
<li class="level2"><a href="#autotoc_md69">Configuration</a></li>
<li class="level2"><a href="#autotoc_md70">Execution</a></li>
</ul>
</li>
<li class="level1"><a href="#the-ear-library">The EAR Library (Job Manager)</a><ul><li class="level2"><a href="#autotoc_md71">Overview</a></li>
<li class="level2"><a href="#autotoc_md72">Configuration</a></li>
<li class="level2"><a href="#autotoc_md73">Usage</a></li>
<li class="level2"><a href="#autotoc_md74">Policies</a></li>
</ul>
</li>
<li class="level1"><a href="#ear-loader">EAR Loader</a></li>
<li class="level1"><a href="#ear-slurm-plugin">EAR SLURM plugin</a><ul><li class="level2"><a href="#autotoc_md75">Configuration</a></li>
<li class="level2"><a href="#autotoc_md76">EAR application API</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ear-node-manager"></a>
EAR Node Manager</h1>
<p>The EAR Daemon (EARD) is a per-node linux service that provides privileged metrics of each node as well as a periodic power monitoring service. Said periodic power metrics can be sent to EAR's database directly, via the EAR Database Daemon (EARDBD) or by using some of the provided <a class="el" href="../../da/df5/md_Report.html">report plug-ins</a>.</p>
<p>See the <a class="el" href="../../df/dde/md_Architecture.html#ear-database-manager">EARDBD</a> section and the <a class="el" href="../../d2/d00/md_Configuration.html">configuration page</a> for more information about the EAR Database Manager and how to to configure the EARD to send its collected data to it.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Overview</h2>
<p>The node Daemon is the component in charge of providing any kind of services that requires privileged capabilities. Current version is conceived as an external process executed with root privileges.</p>
<p>The EARD provides the following services, each one covered by one thread:</p>
<ul>
<li>Provides privileged metrics to EARL such as the average frequency, uncore integrated memory controller counters to compute the memory bandwidth, as well as energy metrics (DC node, DRAM and package energy).</li>
<li>Implements a periodic power monitoring service. This service allows EAR package to control the total energy consumed in the system.</li>
<li>Offers a remote API used by EARplug, EARGM and EAR commands. This API accepts requests such as get the system status, change policy settings or notify new job/end job events.</li>
</ul>
<h2><a class="anchor" id="autotoc_md62"></a>
Requirements</h2>
<p>If using the EAR Database as the storage targe, EARD connects with <a class="el" href="../../df/dde/md_Architecture.html#ear-database-manager">EARDBD</a> service, that has to be up before starting the node daemon, otherwise values reported by EARD to be stored in the database, will be lost.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Configuration</h2>
<p>The EAR Daemon uses the <code>$(EAR_ETC)/ear/ear.conf</code> file to be configured. It can be dynamically configured by reloading the service.</p>
<p>Please visit the <a class="el" href="../../d2/d00/md_Configuration.html#eard-configuration">EAR configuration file page</a> for more information about the options of EARD and other components.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Execution</h2>
<p>To execute this component, these <code>systemctl</code> command examples are provided:</p>
<ul>
<li><code>sudo systemctl start eard</code> to start the EARD service.</li>
<li><code>sudo systemctl stop eard</code> to stop the EARD service.</li>
<li><code>sudo systemctl reload eard</code> to force reloading the configuration of the EARD service.</li>
</ul>
<p>Log messages are generated during the execution. Use <code>journalctl</code> command to see eard message:</p>
<ul>
<li><code>sudo journalctl -u eard -f</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md65"></a>
Reconfiguration</h2>
<p>After executing a <code>systemctl reload eard</code> command, not all the EARD options will be dynamically updated. The list of updated variables are:</p>
<div class="fragment"><div class="line">DefaultPstates</div>
<div class="line">NodeDaemonMinPstate</div>
<div class="line">NodeDaemonVerbose</div>
<div class="line">NodeDaemonPowermonFreq</div>
<div class="line">SupportedPolicies</div>
<div class="line">MinTimePerformanceAccuracy</div>
</div><!-- fragment --><p>To reconfigure other options such as EARD connection port, coefficients, etc., it must be stopped and restarted again. Visit the <a class="el" href="../../d2/d00/md_Configuration.html#eard-configuration">EAR configuration file page</a> for more information about the options of EARD and other components.</p>
<h1><a class="anchor" id="ear-database-manager"></a>
EAR Database Manager</h1>
<p>The EAR Database Daemon (EARDBD) acts as an intermediate layer between any EAR component that inserts data and the EAR's Database, in order to prevent the database server from collapsing due to getting overrun with connections and insert queries.</p>
<p>The Database Manager caches records generated by the <a class="el" href="../../df/dde/md_Architecture.html#the-ear-library">EAR Library</a> and the <a class="el" href="../../df/dde/md_Architecture.html#ear-node-manager">EARD</a> in the system and reports it to the centralized database. It is recommended to run several EARDBDs if the cluster is big enough in order to reduce the number of inserts and connections to the database.</p>
<p>Also, the EARDBD accumulates data during a period of time to decrease the total insertions in the database, helping the performance of big queries. By now just the energy metrics are available to accumulate in the new metric called energy aggregation. EARDBD uses periodic power metrics sent by the EARD, the per-node daemon, including job identification details (Job Id and Step Id when executed in a SLURM system).</p>
<h2><a class="anchor" id="autotoc_md66"></a>
Configuration</h2>
<p>The EAR Database Daemon uses the <code>$(EAR_ETC)/ear/ear.conf</code> file to be configured. It can be dynamically configured by reloading the service.</p>
<p>Please visit the <a href="../../Configuration#eardbd-configuration">EAR configuration file page</a> for more information about the options of EARDBD and other components.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Execution</h2>
<p>To execute this component, these <code>systemctl</code> command examples are provided:</p><ul>
<li><code>sudo systemctl start eardbd</code> to start the EARDBD service.</li>
<li><code>sudo systemctl stop eardbd</code> to stop the EARDBD service.</li>
<li><code>sudo systemctl reload eardbd</code> to force reloading the configuration of the EARDBD service.</li>
</ul>
<h1><a class="anchor" id="ear-global-manager"></a>
EAR Global Manager (System power manager)</h1>
<p>The EAR Global Manager Daemon (EARGMD) is a cluster wide component offering cluster energy monitoring and capping. EARGM can work in two modes: manual and automatic. When running in manual mode, EARGM monitors the total energy consumption, evaluates the percentage of energy consumption over the energy limit set by the admin and reports the cluster status to the DB. When running in automatic mode, apart from evaluating the energy consumption percentage it sends the evaluation to computing nodes. EARDs passes these messages to EARL which re-applies the energy policy with the new settings.</p>
<p>Apart from sending messages and reporting the energy consumption to the DB, EARGM offers additional features to notify the energy consumption: automatic execution of commands is supported and mails can also automatically be sent. Both the command to be executed or the mail address can be defined in the <code>ear.conf</code>, where it can also be specified the energy limits, the monitoring period, etc.</p>
<p>EARGM uses periodic aggregated power metrics to efficiently compute the cluster energy consumption. Aggregated metrics are computed by <a class="el" href="../../df/dde/md_Architecture.html#ear-database-manager">EARDBD</a> based on power metrics reported by <a class="el" href="../../df/dde/md_Architecture.html#ear-node-manager">EARD</a>, the per-node daemon.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note</b>: if you have multiple EARGMs running, only 1 should be used for Energy management. To turn off energy management for a certain EARGM simply set its energy value to 0. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md68"></a>
Power capping</h2>
<p>EARGM also includes an optional power capping system. Power capping can work in two different ways:</p>
<ul>
<li>Cluster power cap (unlimited): Each EARGM controls the power consumption of the nodes under them by ensuring the global power does not exceed a set value. While the global power is under a percentage of the global value, the nodes run without any cap. If it approaches said value, a message is sent to all nodes to set their powercap to a pre-set value (via max_powercap in the tags section of ear.conf). Should the power go back to a value under the cap, a message is sent again so the nodes run at their default value (unlimited power).</li>
<li>Fine grained power cap control: Each EARGM controls the power consumption of the nodes under them and redistributes a certain budget between the nodes, allocating more to nodes who need it. It guarantees that any node has its default powercap allocation (defined by the powercap field in the tags section of ear.conf) if it is running an application.</li>
</ul>
<p>Furthermore, when using fine grained power cap control it is possible to have multiple EARGMs, each controlling a part of the cluster, with (or without) meta-EARGMs redistributing the power allocation of each EARGM depending on the current needs of each part of the cluster. If no meta-EARGMs are specified, the power value each EARGM has will be static.</p>
<p>Meta-EARGMs are NOT compatible with the unlimited cluster powercap mode.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Configuration</h2>
<p>The EAR Global Manager uses the <code>$(EAR_ETC)/ear/ear.conf</code> file to be configured. It can be dynamically configured by reloading the service.</p>
<p>Please visit the <a href="../../Configuration#EARGM-configuration">EAR configuration file page</a> for more information about the options of EARGM and other components.</p>
<p>Additonally, 2 EARGMs can be used in the same host by declaring the environment variable EARGMID to specify which EARGM configuration each should use. If said variable is not declared, all EARGMs in the same host will read the first entry.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
Execution</h2>
<p>To execute this component, these <code>systemctl</code> command examples are provided:</p><ul>
<li><code>sudo systemctl start eargmd</code> to start the EARGM service.</li>
<li><code>sudo systemctl stop eargmd</code> to stop the EARGM service.</li>
<li><code>sudo systemctl reload eargmd</code> to force reloading the configuration of the EARGM service.</li>
</ul>
<h1><a class="anchor" id="the-ear-library"></a>
The EAR Library (Job Manager)</h1>
<p>The EAR Library (EARL) is the core of the EAR package. The Library offers a lightweight and simple solution to select the optimal frequency for applications at runtime, with multiple power policies each with a different approach to find said frequency.</p>
<p>EARL uses the <a class="el" href="../../df/dde/md_Architecture.html#ear-node-manager">Daemon</a> to read performance metrics and to send application data to EAR Database.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
Overview</h2>
<p>EARL is dynamically loaded next to the running applications by the <a class="el" href="../../df/dde/md_Architecture.html#ear-loader">EAR Loader</a>. The Loader detects whether the application is MPI or not. In case it is MPI, it also detects whether it is Intel or OpenMPI, and it intercepts the MPI symbols through the PMPI interface, and next symbols are saved in order to provide compatibility with MPI or other profiling tools. The Library is divided in several stages summarized in the following picture:</p>
<div class="image">
<img src="../../stack.png" alt="" width="50%"/>
</div>
    <ol type="1">
<li>Automatic <b>detection</b> of application outer loops. This is done by intercepting MPI calls and invoking the Dynamic Application Iterative Structure detector algorithm. <b>DynAIS</b> is highly optimized for new Intel architectures, reporting low overhead. For non-MPI applications, EAR implements a time-guided approach.</li>
<li>Computation of the <b>application signature</b>. Once DynAIS starts reporting iterations for the outer loop, EAR starts to compute the application signature. This signature includes: iteration time, DC power consumption, bandwidth, cycles, instructions, etc. Since the DC power measurements error highly depends on the hardware, EAR automatically detects the hardware characteristics and sets a minimum time to compute the signature in order to minimize the average error.</li>
</ol>
<div class="image">
<img src="../../models.png" alt="" width="50%"/>
</div>
    <p>The loop signature is used to <b>classify the application activity</b> in different phases. The current EAR version supports the following phases for: IO bound, CPU computation and GPU idle, CPU busy waiting and GPU computing, CPU-GPU computation, and CPU computation (for CPU only nodes). For phases including CPU computation, the optimization policy is applied. For other phases, the EAR library implements some predefined CPU/Memory/GPU frequency settings.</p>
<ol type="1">
<li><b>Power and performance projection</b>. EAR has its own performance and power models which requires the application and the system signatures as an input. The system signature is a set of coefficients characterizing each node in the system. They are computed during the learning phase at the EAR configuration step. EAR projects the power used and computing time (performance) of the running application for all the available frequencies in the system. These models are applied to CPU metrics and projects CPU performance and power when varying the CPU frequency. Using these projections the optimization policy can select the optimal CPU memory.</li>
</ol>
<div class="image">
<img src="../../projections.png" alt="" width="50%"/>
</div>
    <ol type="1">
<li><b>Apply</b> the selected energy optimization policy. EAR includes two power policies to be selected at runtime: <em>minimize time to solution</em> and <em>minimize energy to solution</em>, if permitted by the system administrator. At this point, EAR executes the power policy, using the projections computed in the previous phase, and selects the optimal frequency for an application and its particular run. An additional policy, <em>monitoring only</em> can also be used, but in this case no changes to the running frequency will be made but only the computation and storage of the application signature and metrics will be done. The short version of the names is used when submitting jobs (min_energy, min_time, monitoring). Current policies already includes memory frequency selection but in this case it is not based on models, it is a guided search. Check in your installation in the memory frequency optimization is enabled by default. In case the application is MPI, the policies already classifies the processes as balanced or unbalanced. In case they are unbalanced, a per-process CPU frequency is applied.</li>
</ol>
<p>Some specific configurations are modified when jobs are executed sharing nodes with other jobs. For example the memory frequency optiization is disabled. See section <a class="el" href="../../d7/d5f/md_EAR_environment_variables.html">environment variables page</a> for more information on how to tune the EAR library optimization using environment variables.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Configuration</h2>
<p>The Library uses the <code>$(EAR_ETC)/ear.conf</code> file to be configured. Please visit the <a href="../../Configuration#EARL-configuration">EAR configuration file page</a> for more information about the options of EARL and other components.</p>
<p>EARL receives its specific settings through a shared memory regions initialized by <a class="el" href="../../df/dde/md_Architecture.html#ear-node-manager">EARD</a>.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
Usage</h2>
<p>For information on how to run applications alongside with EARL read the <a class="el" href="../../d6/d86/md_User_guide.html">User guide</a>. Next section contains more information regarding EAR's optimisation policies.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
Policies</h2>
<p>EAR offers three energy policies plugins: <code>min_energy</code>, <code>min_time</code> and <code>monitoring</code>. The last one is not a power policy, is used just for application monitoring where CPU frequency is not modified (neither memory or GPU frequency). For application analysis <code>monitoring</code>can be used with specific CPU, memory and/or GPU frequencies.</p>
<p>The energy policy is selected by setting the <code>--ear-policy=policy</code> option when submitting a SLURM job. A policy parameter, which is a particular value or threshold depending on the policy, can be set using the flag <code>--ear-policy-th=value</code>. Its default value is defined in the configuration file, for more information check the <a class="el" href="../../d2/d00/md_Configuration.html">configuration page</a> for more information.</p>
<h3><code>min_energy</code></h3>
<p>The goal of this policy is to minimise the energy consumed with a limit to the performance degradation. This limit is is set in the SLURM <code>--ear-policy-th</code> option or the configuration file. The <code>min_energy</code> policy will select the optimal frequency that minimizes energy enforcing (performance degradation &lt;= parameter). When executing with this policy, applications starts at default frequency(specified at ear.conf).</p>
<div class="fragment"><div class="line">PerfDegr = (CurrTime - PrevTime) / (PrevTime)</div>
</div><!-- fragment --><h3><code>min_time</code></h3>
<p>The goal of this policy is to improve the execution time while guaranteeing a minimum ratio between performance benefit and frequency increment that justifies the increased energy consumption from this frequency increment. The policy uses the SLURM parameter option mentioned above as a minimum efficiency threshold.</p>
<p><b>Example:</b> if <code>--ear-policy-th=0.75</code>, EAR will prevent scaling to upper frequencies if the ratio between performance gain and frequency gain do not improve at least 75% (PerfGain &gt;= (FreqGain * threshold).</p>
<div class="fragment"><div class="line">PerfGain=(PrevTime-CurrTime)/PrevTime</div>
<div class="line">FreqGain=(CurFreq-PrevFreq)/PrevFreq</div>
</div><!-- fragment --><p>When launched with <code>min_time</code> policy, applications start at a default frequency (defined at <code>ear.conf</code>). Check the <a class="el" href="../../d2/d00/md_Configuration.html">configuration page</a> for more information.</p>
<p><b>Example:</b> given a system with a nominal frequency of 2.3GHz and default P_STATE set to 3, an application executed with <code>min_time</code> will start with frequency <code>F\\\[i\\\]=2.0Ghz</code> (3 P_STATEs less than nominal). When application metrics are computed, the library will compute performance projection for <code>F\\\[i+1\\\]</code> and will compute the performance_gain as shown in the Figure 1. If performance gain is greater or equal than threshold, the policy will check with the next performance projection <code>F\\\[i+2\\\]</code>. If the performance gain computed is less than threshold, the policy will select the last frequency where the performance gain was enough, preventing the waste of energy.</p>
<div class="image">
<img src="../../min_time_example.png" alt="" width="50%"/>
</div>
    <p>Figure 1: <code>min_time</code> uses the threshold value as the minimum value for the performance gain between <code>F\\\[i\\\]</code> and <code>F\\\[i+1\\\]</code>.</p>
<h1><a class="anchor" id="ear-loader"></a>
EAR Loader</h1>
<p>The EAR Loader is the responsible for loading the EAR Library. It is a small and lightweight library loaded by the <a class="el" href="../../df/dde/md_Architecture.html#ear-slurm-plugin">EAR SLURM Plugin</a> (through the <code>LD_PRELOAD</code> environment variable) that identifies the user application and loads its corresponding EAR Library distribution.</p>
<p>The Loader detects the underlying application, identifying the MPI version (if used) and other minor details. With this information, the loader opens the suitable EAR Library version.</p>
<p>As can be read in the <a class="el" href="../../df/dde/md_Architecture.html#the-ear-library">EARL</a> page, depending on the MPI vendor the MPI types can be different, preventing any compatibility between distributions. For example, if the MPI distribution is OpenMPI, the EAR Loader will load the EAR Library compiled with the OpenMPI includes.</p>
<p>You can read the <a class="el" href="../../d8/d71/md_Admin_guide.html#quick-installation-guide">installation guide</a> for more information about compiling and installing different EARL versions.</p>
<h1><a class="anchor" id="ear-slurm-plugin"></a>
EAR SLURM plugin</h1>
<p>EAR SLURM plugin allows to dynamically load and configure the EAR library for the SLURM jobs (and steps), if the flag <code>--ear=on</code> is set or if it is enabled by default. Additionally, it reports any jobs that start or end to the nodes' EARDs for accounting and monitoring purposes.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
Configuration</h2>
<p>Visit the <a class="el" href="../../d2/d00/md_Configuration.html#slurm-spank-plugin-configuration-file">SLURM SPANK plugin section</a> on the configuration page to set up properly the SLURM <code>/etc/slurm/plugstack.conf</code> file.</p>
<p>You can find the complete list of EAR SLURM plugin accpeted parameters in the <a class="el" href="../../d6/d86/md_User_guide.html#ear-job-submission-flags">user guide</a>.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
EAR application API</h2>
<p>EAR offers a user API for applications. The current EAR version only offers two sets of functions:</p>
<ul>
<li>To measure the energy consumption</li>
<li>To set the cpu and gpu frequencies .</li>
<li><code>int ear_connect()</code></li>
<li><code>int ear_energy(unsigned long \\\*energy_mj, unsigned long \\\*time_ms)</code></li>
<li><code>void ear_energy_diff(unsigned long ebegin, unsigned long eend, unsigned long \\\*ediff, unsigned long tbegin, unsigned long tend, unsigned long \\\*tdiff)</code></li>
<li><code>int ear_set_cpufreq(cpu_set_t \\\*mask,unsigned long cpufreq);</code></li>
<li><code>int ear_set_gpufreq(int gpu_id,unsigned long gpufreq)</code></li>
<li><code>int ear_set_gpufreq_list(int num_gpus,unsigned long \\\*gpufreqlist)</code></li>
<li><code>void ear_disconnect()</code></li>
</ul>
<p>EAR's header file and library can be found at $EAR_INSTALL_PATH/include/ear.h and $EAR_INSTALL_PATH/lib/libEAR_api.so respectively. The following example reports the energy, time, and average power during that time for a simple loop including a <code>sleep(5)</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define _GNU_SOURCE</span></div>
<div class="line"><span class="preprocessor">#include &lt;ear.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> e_mj=0,t_ms=0,e_mj_init,t_ms_init,e_mj_end,t_ms_end=0;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ej,emj,ts,tms,os,oms;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ej_e,emj_e,ts_e,tms_e,os_e,oms_e;</div>
<div class="line">  <span class="keywordtype">int</span> i=0;</div>
<div class="line">  <span class="keyword">struct </span>tm *tstamp,*tstamp2,*tstamp3,*tstamp4;</div>
<div class="line">  <span class="keywordtype">char</span> s[128],s2[128],s3[128],s4[128];</div>
<div class="line">  </div>
<div class="line">  <span class="comment">/* Connecting with ear */</span></div>
<div class="line">  <span class="keywordflow">if</span> (ear_connect()!=EAR_SUCCESS)</div>
<div class="line">  {</div>
<div class="line">    printf(<span class="stringliteral">&quot;error connecting eard\n&quot;</span>);</div>
<div class="line">    exit(1);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Reading energy */</span></div>
<div class="line">  <span class="keywordflow">if</span> (ear_energy(&amp;e_mj_init,&amp;t_ms_init)!=EAR_SUCCESS)</div>
<div class="line">  {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Error in ear_energy\n&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">while</span>(i&lt;5)</div>
<div class="line">  {</div>
<div class="line">    sleep(5);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* READING ENERGY */</span></div>
<div class="line">    <span class="keywordflow">if</span> (ear_energy(&amp;e_mj_end,&amp;t_ms_end)!=EAR_SUCCESS)</div>
<div class="line">    {</div>
<div class="line">      printf(<span class="stringliteral">&quot;Error in ear_energy\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      ts=t_ms_init/1000;</div>
<div class="line">      ts_e=t_ms_end/1000;</div>
<div class="line">      tstamp=localtime((time_t *)&amp;ts);</div>
<div class="line">      strftime(s, <span class="keyword">sizeof</span>(s), <span class="stringliteral">&quot;%c&quot;</span>, tstamp);</div>
<div class="line">              tstamp2=localtime((time_t *)&amp;ts_e);</div>
<div class="line">              strftime(s2, <span class="keyword">sizeof</span>(s), <span class="stringliteral">&quot;%c&quot;</span>, tstamp2);</div>
<div class="line"> </div>
<div class="line">      printf(<span class="stringliteral">&quot;Start time %s End time %s\n&quot;</span>,s,s2);</div>
<div class="line">      ear_energy_diff(e_mj_init,e_mj_end, &amp;e_mj, t_ms_init,t_ms_end,&amp;t_ms);</div>
<div class="line">      printf(<span class="stringliteral">&quot;Time consumed %lu (ms), energy consumed %lu(mJ), </span></div>
<div class="line"><span class="stringliteral">             Avg power %lf(W)\n&quot;</span>,t_ms,e_mj,(<span class="keywordtype">double</span>)e_mj/(<span class="keywordtype">double</span>)t_ms);</div>
<div class="line">      e_mj_init=e_mj_end;</div>
<div class="line">      t_ms_init=t_ms_end;</div>
<div class="line">    }</div>
<div class="line">    i++;</div>
<div class="line">  }</div>
<div class="line">  ear_disconnect();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
