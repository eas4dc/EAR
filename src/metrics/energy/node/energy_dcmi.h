/*
*
* This program is part of the EAR software.
*
* EAR provides a dynamic, transparent and ligth-weigth solution for
* Energy management. It has been developed in the context of the
* Barcelona Supercomputing Center (BSC)&Lenovo Collaboration project.
*
* Copyright Â© 2017-present BSC-Lenovo
* BSC Contact   mailto:ear-support@bsc.es
* Lenovo contact  mailto:hpchelp@lenovo.com
*
* This file is licensed under both the BSD-3 license for individual/non-commercial
* use and EPL-1.0 license for commercial use. Full text of both licenses can be
* found in COPYING.BSD and COPYING.EPL files.
*/

#ifndef METRICS_NODE_IPMI_DCMI_POWER_H
#define METRICS_NODE_IPMI_DCMI_POWER_H

#include <stdint.h>

#define IPMI_BUF_SIZE	1024
#define IPMI_SYSTEM_INTERFACE_ADDR_TYPE	0x0c

#define DCMI_GROUP_EXT 0xDC
#define DCGRP 0x2C


#define DCMI_NETFN	      0x2C
#define DCMI_NETFN1	      0x2D

/* DCMI COMMANDS */
#define DCMI_CMD_GET_CAP 		0x01
#define DCMI_CMD_GET_POWER	0x02


/* Extra defines */
/* For DCMI_CMD_GET_CAP */
#define DCMI_PARAM_SUP_CAP	1
#define DCMI_PARAM_MANDATORY_PLAT 2
#define DCMI_PARAM_OPTIONAL_PLAT 3
#define DCMI_PARAM_ENH_POWER		5

typedef struct dcmi_power_data{
	unsigned long  current_power,min_power,max_power,avg_power;
	unsigned long  timeframe,timestamp;
}dcmi_power_data_t;



struct ipmi_rq {
	struct {
		uint8_t netfn:6;
		uint8_t lun:2;
		uint8_t cmd;
		uint8_t target_cmd;
		uint16_t data_len;
		uint8_t *data;
	} msg;
};

struct ipmi_rs {
	int data_len;

	uint8_t ccode;
	uint8_t data[IPMI_BUF_SIZE];

	/*
	 * Looks like this is the length of the entire packet, including the RMCP
	 * stuff, then modified to be the length of the extra IPMI message data
	 */
//	int data_len;

	struct {
		uint8_t netfn;
		uint8_t cmd;
		uint8_t seq;
		uint8_t lun;
	} msg;

	struct {
		uint8_t authtype;
		uint32_t seq;
		uint32_t id;
		uint8_t bEncrypted;	/* IPMI v2 only */
		uint8_t bAuthenticated;	/* IPMI v2 only */
		uint8_t payloadtype;	/* IPMI v2 only */
		/* This is the total length of the payload or
		   IPMI message.  IPMI v2.0 requires this to
		   be 2 bytes.  Not really used for much. */
		uint16_t msglen;
	} session;

	/*
	 * A union of the different possible payload meta-data
	 */
	union {
		struct {
			uint8_t rq_addr;
			uint8_t netfn;
			uint8_t rq_lun;
			uint8_t rs_addr;
			uint8_t rq_seq;
			uint8_t rs_lun;
			uint8_t cmd;
		} ipmi_response;
		struct {
			uint8_t message_tag;
			uint8_t rakp_return_code;
			uint8_t max_priv_level;
			uint32_t console_id;
			uint32_t bmc_id;
			uint8_t auth_alg;
			uint8_t integrity_alg;
			uint8_t crypt_alg;
		} open_session_response;
		struct {
			uint8_t message_tag;
			uint8_t rakp_return_code;
			uint32_t console_id;
			uint8_t bmc_rand[16];	/* Random number generated by the BMC */
			uint8_t bmc_guid[16];
			uint8_t key_exchange_auth_code[20];
		} rakp2_message;
		struct {
			uint8_t message_tag;
			uint8_t rakp_return_code;
			uint32_t console_id;
			uint8_t integrity_check_value[20];
		} rakp4_message;
		struct {
			uint8_t packet_sequence_number;
			uint8_t acked_packet_number;
			uint8_t accepted_character_count;
			uint8_t is_nack;	/* bool */
			uint8_t transfer_unavailable;	/* bool */
			uint8_t sol_inactive;	/* bool */
			uint8_t transmit_overrun;	/* bool */
			uint8_t break_detected;	/* bool */
		} sol_packet;

	} payload;
};
struct valstr {
	uint16_t val;
	const char * str;
};

//#endif

//======for open and send=================================
#define IPMI_MAX_ADDR_SIZE    0x20
#define IPMI_BMC_CHANNEL    0x0f
#define IPMI_NUM_CHANNELS   0x10
#define IPMI_IPMB_ADDR_TYPE   0x01
#define IPMI_IPMB_BROADCAST_ADDR_TYPE 0x41

struct ipmi_system_interface_addr {
	int addr_type;
	short channel;
	unsigned char lun;
};

struct ipmi_ipmb_addr {
	int addr_type;
	short channel;
	unsigned char slave_addr;
	unsigned char lun;
};

struct ipmi_addr {
	int addr_type;
	short channel;
	char data[IPMI_MAX_ADDR_SIZE];
};

struct ipmi_msg {
	unsigned char netfn;
        unsigned char cmd;
        unsigned short data_len;
        unsigned char *data;
};

struct ipmi_req {
	unsigned char *addr;
	unsigned int addr_len;
	long msgid;
	struct ipmi_msg msg;
};

struct ipmi_recv {
	int recv_type;
	unsigned char *addr;
	unsigned int addr_len;
	long msgid;
	struct ipmi_msg msg;
};


#define IPMICTL_RECEIVE_MSG_TRUNC	_IOWR('i', 11, struct ipmi_recv)
#define IPMICTL_SEND_COMMAND            _IOR('i', 13, struct ipmi_req)
#define IPMICTL_RECEIVE_MSG		_IOWR('i', 12, struct ipmi_recv)
#define IPMICTL_SET_MY_ADDRESS_CMD	_IOR('i', 17, unsigned int)

struct ipmi_data{
	int mode;
	uint8_t data[256];
	int data_len;
};
struct ipmi_intf{
int fd;
uint8_t addr;
uint8_t channel;
};

#endif
