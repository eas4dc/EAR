/*
*
* This program is part of the EAR software.
*
* EAR provides a dynamic, transparent and ligth-weigth solution for
* Energy management. It has been developed in the context of the
* Barcelona Supercomputing Center (BSC)&Lenovo Collaboration project.
*
* Copyright © 2017-present BSC-Lenovo
* BSC Contact   mailto:ear-support@bsc.es
* Lenovo contact  mailto:hpchelp@lenovo.com
*
* This file is licensed under both the BSD-3 license for individual/non-commercial
* use and EPL-1.0 license for commercial use. Full text of both licenses can be
* found in COPYING.BSD and COPYING.EPL files.
*/
#include <stdlib.h>

/** Given two doubles a and b, checks if they are equal within a margin of th.*/
unsigned int equal_with_th(double a, double b, double th);
uint equal_with_th_ul(ulong a,ulong b,double th);


/** Given two unsigned long's, one before and one after overflow, returns the
*   value added to the first to obtain the second. This corrects end-begin when there 
*   has been an overflow. */
unsigned long ulong_diff_overflow(unsigned long begin, unsigned long end);

/** Given two unsigned long's, one before and one after overflow, returns the
*   value added to the first to obtain the second. This corrects end-begin when there 
*   has been an overflow. */
unsigned long long ullong_diff_overflow(unsigned long long begin, unsigned long long end);

/** Given two long long's, one before and one after overflow, returns the
*   value added to the first to obtain the second. 
*   This corrects end-begin when there has been an overflow.*/
long long llong_diff_overflow(long long begin, long long end);

/** Given a generic 2d array ('len' x 1) 'arr' and a function 'fn_ptr' (which
 * will convert the input type for its own computation), returns a new generic
 * array where each entry is the result of applying 'fn_ptr' to each entry of 'arr',
 * respectively.
 * This function will dynamically allocate memory space for the resulting array, so
 * it's recommended to call ear_math_free_gen_arr after using the resulting array.
 * */
void** ear_math_apply(void **arr, size_t len, void* (*fn_ptr)(void*));

/**
 * Frees some 2d generic array mostly generated by the function ear_math_apply.  */
void ear_math_free_gen_array(void **arr);

/** Given two vectors 'a' and 'b' of size 'n', returns its cosine similarity, which is
 *                  A·B
 *  cos(phi) =  ------------
 *              ||A||*||B||
 * */
double ear_math_cosine_similarity(double *a, double *b, size_t n);

double ear_math_cosine_sim_uint(uint *a, uint *b, size_t n);

typedef struct mean_sd {
    double mean;
    double sd;
    double mag;
} mean_sd_t;

mean_sd_t ear_math_mean_sd(const double data[], size_t n);

/** Given a vector 'data' with 'n' values, returns the mean.  */
double ear_math_mean(const double data[], size_t n);

/** Given a vector 'data' with 'n' values and its mean 'mean', returns the
 * standard deviation of the data. */
double ear_math_standard_deviation(const double data[], size_t n, double mean);

double ear_math_exp(double x);

double ear_math_scale(double src_range_min, double src_range_max, double n);

float ear_math_roundf(float n);

double ear_math_median(const double data[], size_t n);
